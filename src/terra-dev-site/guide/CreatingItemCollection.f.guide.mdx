import ResponsiveListandTableExample from '../example/ResponsiveListandTableExample?dev-site-example';
import ResponsiveListandCellGridExample from '../example/ResponsiveListandCellGridExample?dev-site-example';
import ResponsiveListandHtmlTableExample from '../example/ResponsiveListandHtmlTableExample?dev-site-example';

# Creating An Item Collection

Start by making a `ResponsiveElement` that will switch between its two sub-components, a `Table` version of the content when above a certain size and a `List` version of the same content as the default display. In this `ResponsiveElement`, we set 3 attributes. The first is the defaultElement which is just the `List` version of the content. The second is the `responsiveTo` attribute, which determines what the component compares itself to in order to resizes itself, its parent or the window. Terra's `ItemCollection` surrounds its `ResponsiveElement` in a `<div>` tag, and sets `responsiveTo` to `parent`. Finally the breakpoint you want to switch at is defined by setting one of the following attributes: `tiny`, `small`, `medium`, `large`, or `huge` to the `Table` version of the content.

The following is a simplified example of what the code should look like.

```javascript
  <ResponsiveElement
    responsiveTo="parent"
    defaultElement={listDisplay}
    medium={tableDisplay}
  />
```

With the base `ResponsiveElement` now set up, making the two displays versions of content is next.

## Replicating the Deprecated Terra Clinical Item Collection

### Creating the List version

Start with a Terra `List` component and define these two props: `dividerStyles` and `role`. `dividerStyle` is used to determine if and where you want the border-color to be applied to each of the children and can have the values 'none', 'standard', 'bottom-only'. `role` is only used if the children you have in `List` are selectable, and if they are, is defined as 'listbox'.

```javascript
  const listDisplay = (
  <List dividerStyle="none" role="listbox">
    {children}
  </List>);
```

Next we build the children that are going into this `<List>`. Each child should be wrapped in `terra-list`'s `<Item>` and as display in an `<ItemView>` from `terra-clinical-item-view`.

```javascript
  var listChild = (
    <Item>
      <ItemView
        displays={React.Children.toArray(children)}
      />
    </Item>
  );
```

The props listed in the code examples are the ones set in `terra-clinical-item-collection`, however there are plenty more to be set as needed listed in the `terra-list` documentation. A quirk to pay attention to is if `isSelectable` is used on `<Item>`, `tabIndex` should be added to the `<Item>` and set to `0`.

## Creating Single Selectable Table version

For `tableDisplay`, we start with this.

```javascript
  const tableDisplay = (
    <Table
      summaryId="standard-table"
      summary="This table has standard padding"
      numberOfColumns={mockData[0].cells.length}
      dividerStyle="horizontal"
      rowStyle="disclose"
      bodyData={[
        {
          rows: createRows(mockData),
        },
      ]}
      className={cx('table')}
    />
  );
```

`summaryId` is an element-id for the component, `summary` is just a brief text to describe the table's content, and `className` is just add some CSS. `numberOfColumns` is also pretty self-explanatory as how many columns you will need in the table. `dividerStyle` is used to put divisions between rows.

`rowStyle` we define as 'disclose' because in our example our rows are selectable to then disclose further information upon selection.

In our particular example, we created a mock data object we parse through to create the rows and cells. The `createRows` function which looks like this.

```javascript
const createRow = rowData => (
  {
    key: rowData.key,
    isStriped: rowData.isStriped,
    cells: createCellsForRow(rowData.cells),
    discloseAction: {
      metaData: { key: rowData.key },
      discloseLabel: rowData.discloseText,
      isDisclosed: selectedKey === rowData.key,
      discloseCellIndex: 0,
      onDisclose: handleRowDisclose,
    },
  }
);
```

Each row needs a `key` which is a unique identifier, in our example it is 'row-0', 'row-1', etc. `isStriped` is set to 'true' every other row to give a close appearance to past item-collection.

`discloseAction` is a special object for use when we select that row. `metaData` just contains a key for that row and `discloseLabel` is just a brief description the row such as 'Power Row 0 - Details'. `isDisclosed` is 'true' only when our component's state matches with the metadata key. `discloseCellIndex` is the index of the cell that provides the accessible link entry point.

`onDisclose` is a simple state update function as seen here.

```javascript
const handleRowDisclose = (event, metaData) => {
  event.preventDefault();
  if (selectedKey !== metaData.key) {
    setSelectedKey(metaData.key);
  }
};
```

For creating cells in each row we do this

```javascript
const createCellsForRow = cells => cells.map(cell => createCell(cell));
const createCell = cell => ({ key: cell.key, children: cell.children, attrs: cell.attrs });
```

Cells are simple and just require a key, the children of said cell and then we use `attrs` to set `className` in our example like so.

```javascript
const attrs = { className: cx('content-display')};
```

## Creating a Cell Grid that looks like a Table

Instead of using `<Table>`, you can use `<CellGrid>` to create another version of the default content when over a certain window size. This method requires a little bit of CSS to be put in place to get a closer match to `<Table>`'s default style. The basic content look of it looks like this.

```javascript
  const cellGridDisplay = (
    <div className={cx('cellgrid-wrapper')}>
      <CellGrid className={cx('row')}>
        <Cell className={cx('start-accessory')} key="cell-0" width={{ static: { value: 40, unit: 'px' } }}>{startAccessory}</Cell>
        <Cell className={cx('display')} key="cell-i" width={{ scalar: 1 }}>{display}</Cell>
        ...
      </CellGrid>
      ...
    </div>
  );
```

In this example, the `<CellGrid>` effectively act as rows and doesn't require any props other than defining a class for it. The `<Cell>`'s are where the content is placed. In the example provided at the bottom of this page, the content has two accessories on either side of the main information. Setting these accessories `width` prop to `{ static: { value: 40, unit: 'px' } }` allows the accessories to only take up a small amount of space, while the rest of the `Cell`'s use `{ scalar: 1 }` for width to automatically take up an equal percentage of the remaining space.

For the main styles it uses the following CSS.

```css
.cellgrid-wrapper {
  border-bottom: 1px solid #c8cacb;
}

.row {
  border-top: 1px solid #c8cacb;
  display: flex;
  min-height: 60px;
}

.row:nth-child(even) {
  background: #f4f4f4;
}
```

## Creating a read-only example using HTML table

If you are making a read-only table, we suggest using HTML Table which gets put together like this.

```javascript
const htmlTable = (
  <Table>
    <Header>
      <HeaderCell key="cell-date">{"Date"}</HeaderCell>
      <HeaderCell key="cell-1">{"Chrome"}</HeaderCell>
      ...
    </Header>
    <Body>
      <Row key="row_0">
        <Cell key="display_0" className={cx('cell-date')}>{"October 2019"}</Cell>
        <Cell key="display_1" className={cx('cell')}>{"68.91%"}</Cell>
        ...
      </Row>
      ...
    </Body>
  </Table>
);
```

It uses a straightforward Header and Body section. The header section is composed of `<HeaderCell>`'s which just needs a simple key and child for its display.

The body `<Row>`s and `<Cell>`s are also for the most part easily constructed with keys required for both. The `<Cell>`s also get classes for ease of styling and children for actual content.

## Example
<ResponsiveListandTableExample title='Responsive List And Table Example' />
<ResponsiveListandCellGridExample title='Responsive List And Cell Grid Example' />
<ResponsiveListandHtmlTableExample title='Responsive List And HTML Table Example' />
